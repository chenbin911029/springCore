2018-03-14
jvm运行机制
JVM启动流程
JVM基本结构
内存模型
编译和解释运行的概念

               内存空间
方法区  Java堆  Java栈  本地方法栈 pc寄存器
                                每个线程有一个pc寄存器
方法区：保存装载类的信息，类型的常量池，字段，方法信息
        方法字节码
Java堆：线程共享
新生代      老年代
eden s0 s1 tenured
复制算法

Java栈：线程私有
保存方法的局部变量，操作数，常量池指针
栈上分配
volatile 可以使一个线程修改的变量在
其它线程上可见，不是线程安全的。

保证可见性：
volatile
synchronized
final
指令重排


垃圾回收器

可达性分析算法
新生代一次回收可以回收70%-95%的空间

标记-清除算法，会产生大量不连续的内存碎片
效率问题：标记和清除两个过程的效率都不高

复制算法：新生代使用该算法
可用内存分为大小相等的两块，每次只使用其中的一块
当这块使用完了，就将还存活的对象复制到另一块上面
然后把已使用过的内存空间一次清理掉。
这样每次都可以对整个半区进行内存回收，
内存分配也不用考虑内存碎片的问题。
但是这样只能使用到一半的内存，所以改良后
Java堆
8:1:1 hotspot
分为eden区 survivor1 survivor2
当回收时，将eden和survivor1还存活的对象一次性复制
到survivor2中，最后清理eden和survivor1的内存空间，
也就是，每次新生代中可用的内存空间为整个新生代容量的
90%。

3.3.3标记-整理算法
标记要回收的对象，然后将存活对象向一端移动，然后
直接清理掉端边界以外的内存。

3.3.4分代收集算法
新生代使用复制回收算法
老年代使用标记整理算法，或者标记-清理算法。

Hotspot算法实现
3.4.1枚举根节点
GC 进行时必须停顿所有Java执行线程，分析结果的准确性

新生代，老年代
Java堆
方法区

3.6内存分配与回收策略
eden
新生代GC minor GC
老年代GC Major GC

-xx:pretenureSizeThreshold参数，大于这个值直接分配
到老年代，避免新生代发生大量的内存复制

长期存活的对象将进入老年代
对象age,每minor GC 一次存活下来age+1
回收15次依然存活，则进入老年代
-xx:maxTenuringThreadshold





















































